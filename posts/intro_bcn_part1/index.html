<!DOCTYPE html>
<html lang="en-us">

<head>
  
  <meta charset="utf-8">



<meta name="viewport" content="width=device-width, initial-scale=1.0">


  
    <meta name="description" content="Texture block compression is a critical component of real-time rendering. Reducing the size of textures saves download time, disk space, memory, and GPU bandwidth. With a few exceptions (pixel art, some UI elements), it&rsquo;s a reasonable expectation that all textures should be compressed to maximize these benefits.
It&rsquo;s important, therefore, to understand how texture block compression works at a high level. What formats work best for base colors versus normal maps versus some arbitrary packed material data?">
  


<meta name="color-scheme" content="light dark">







<meta name="generator" content="Hugo 0.121.1">
  <title>An Introduction To BCn Texture Compression, Part 1: BC4 | Devfault v2</title>
  <link rel="canonical" href="https://acefanatic02.github.io/posts/intro_bcn_part1/">




  








  
    
  
  
  <link rel="stylesheet" href="/css/base.min.2319cf9fece58247a471ab5aa45e75133ecd35b25017de77acaf299ef081c705.css" integrity="sha256-IxnPn&#43;zlgkekcatapF51Ez7NNbJQF953rK8pnvCBxwU=" crossorigin="anonymous">



</head>

<body>
  <nav class="u-background">
  <div class="u-wrapper">
    <ul class="Banner">
      <li class="Banner-item Banner-item--title">
        <h1 class="Banner-heading">
          <a class="Banner-link u-clickable" href="/">Devfault v2</a>
        </h1>
      </li>
      
        <li class="Banner-item">
          <a class="Banner-link u-clickable" href="/about/">About</a>
        </li>
      
        <li class="Banner-item">
          <a class="Banner-link u-clickable" href="/">Posts</a>
        </li>
      
        <li class="Banner-item">
          <a class="Banner-link u-clickable" href="/tags/">Tags</a>
        </li>
      
        <li class="Banner-item">
          <a class="Banner-link u-clickable" href="/categories/">Categories</a>
        </li>
      
        <li class="Banner-item">
          <a class="Banner-link u-clickable" href="/index.xml">RSS</a>
        </li>
      
    </ul>
  </div>
</nav>

  <main>
    <div class="u-wrapper">
      <div class="u-padding">
        

  <article>
    <header class="Heading">
  <h2 class="Heading-title">
    <a class="Heading-link u-clickable" href="/posts/intro_bcn_part1/" rel="bookmark">An Introduction To BCn Texture Compression, Part 1: BC4</a>
  </h2>
  
    <time datetime="2024-01-28T00:00:00Z">28 January, 2024</time>
  
</header>
    <p>Texture block compression is a critical component of real-time rendering.  Reducing the size of textures saves download time, disk space, memory, and GPU bandwidth.  With a few exceptions (pixel art, some UI elements), it&rsquo;s a reasonable expectation that all textures should be compressed to maximize these benefits.</p>
<p>It&rsquo;s important, therefore, to understand how texture block compression works at a high level.  What formats work best for base colors versus normal maps versus some arbitrary packed material data?  What tradeoffs can be expected between quality, size, and compression time?  That is not the topic of this post; Nathan Reed has <a href="https://www.reedbeta.com/blog/understanding-bcn-texture-compression-formats/">an excellent writeup</a> on the various BCn texture formats and there&rsquo;s no need to duplicate it here.</p>
<p>Instead, this series is going to dig into the next level of understanding.  Sometimes it&rsquo;s not enough to treat the actual compression process as a black box.  Maybe you need to compress textures at runtime on the GPU, or modify the compression to account for a different error term (e.g., error after RGBM decoding). Maybe you need to investigate non-determinism in your texture import pipeline.  Or maybe you&rsquo;re just curious about the techniques involved.</p>
<p>So you go open up the source of your compression library, and&hellip;</p>
<p>Oh, ew.  Weird integer math!  Bit twiddling!  Vectorization!</p>
<p>None of these things are <em>bad</em>, of course, and I&rsquo;d be perfectly comfortable with them in an area of code I was familiar with.  They do, however, tend to make it a lot harder to understand what a given block of code is <em>actually doing</em> if you don&rsquo;t know already.  (Which is maybe a lesson to learn about the readability of code in general.)</p>
<p>When I started trying to learn how block compression worked, I was frustrated at how few resources there were going over the basics.  The goal of this series, then, is to outline some of the core algorithms in block compression, in a clearer form.  Then, we can build up to some of the common tricks and optimizations.  With that understanding, it should be possible to look at a real, production compressor and understand what it is doing.</p>
<h3 id="bc4">
  <a class="Heading-link u-clickable" href="/posts/intro_bcn_part1/#bc4">BC4</a>
</h3>
<p>BC4 is the simplest of the formats, and therefore a good place to start.  A BC4 block is 8 bytes, covering 4x4 texels, with two single-channel 8-bit endpoint values as well as 16 3-bit selector values (which are packed tightly together in the remaining 6 bytes.)  Written out as a C struct:</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#66d9ef">bc4_packed_block_t</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint8_t</span> endpoint0;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint8_t</span> endpoint1;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint8_t</span> packed_selectors[<span style="color:#ae81ff">6</span>];
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<p>Like all BCn formats, BC4 assumes the values in a block can be represented as a gradient.  But what does that actually mean?  When decoding a block, the endpoints are used to construct an 8-element palette.  The selectors for each texel index into this palette to produce the final result.</p>
<p>For BC4, there are two possible methods for constructing the palette, depending on the relative magnitudes of the endpoints.  (The &lsquo;degeneracy breaking&rsquo; mentioned in Nathan&rsquo;s blog post.)  Most entries are a linear combination of the two endpoints, although the second mode contains two constant entries as well.  Unfortunately, the ordering of entries in this palette is&hellip; a little unintuitive:</p>
<table>
<thead>
<tr>
<th style="text-align:center">palette entry</th>
<th>8-color mode (endpoint0 &gt; endpoint1)</th>
<th>6-color mode (endpoint0 &lt;= endpoint1)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td>endpoint0</td>
<td>endpoint0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td>endpoint1</td>
<td>endpoint1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td>(endpoint0 * 6 + endpoint1 * 1) / 7</td>
<td>(endpoint0 * 4 + endpoint1 * 1) / 5</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td>(endpoint0 * 5 + endpoint1 * 2) / 7</td>
<td>(endpoint0 * 3 + endpoint1 * 2) / 5</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td>(endpoint0 * 4 + endpoint1 * 3) / 7</td>
<td>(endpoint0 * 2 + endpoint1 * 3) / 5</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td>(endpoint0 * 3 + endpoint1 * 4) / 7</td>
<td>(endpoint0 * 1 + endpoint1 * 4) / 5</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td>(endpoint0 * 2 + endpoint1 * 5) / 7</td>
<td>0</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td>(endpoint0 * 1 + endpoint1 * 6) / 7</td>
<td>255</td>
</tr>
</tbody>
</table>
<p>In practice, BC4 can produce fairly high quality results using only the 8-color mode (i.e., <code>endpoint0</code> is the maximum.)  The later palette can help slightly with blocks that include outlier texels, however.</p>
<p>Okay, that should be enough background to let us write a simple compressor!</p>
<p>First, we&rsquo;ll use a different, unpacked struct during the encoding process itself, just to avoid dealing with all of the bitpacking:</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> k_texels_per_block <span style="color:#f92672">=</span> <span style="color:#ae81ff">16</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#66d9ef">bc4_block_t</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint8_t</span> endpoint0;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint8_t</span> endpoint1;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint8_t</span> selectors[k_texels_per_block]; <span style="color:#75715e">// 3-bit indices
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};</span></span></code></pre></div>
<p>And a function to pack this into a proper output block:</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">bc4_packed_block_t</span> <span style="color:#a6e22e">pack_bc4</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">bc4_block_t</span><span style="color:#f92672">*</span> block)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">bc4_packed_block_t</span> result <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint64_t</span> packed_selectors <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">_countof</span>(block<span style="color:#f92672">-&gt;</span>selectors); <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">assert</span>(block<span style="color:#f92672">-&gt;</span>selectors[i] <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">8</span>);
</span></span><span style="display:flex;"><span>		packed_selectors <span style="color:#f92672">|=</span> ((<span style="color:#66d9ef">uint64_t</span>)block<span style="color:#f92672">-&gt;</span>selectors[i] <span style="color:#f92672">&lt;&lt;</span> (i <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span>));
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	result.endpoint0 <span style="color:#f92672">=</span> block<span style="color:#f92672">-&gt;</span>endpoint0;
</span></span><span style="display:flex;"><span>	result.endpoint1 <span style="color:#f92672">=</span> block<span style="color:#f92672">-&gt;</span>endpoint1;
</span></span><span style="display:flex;"><span>	result.packed_selectors[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>(packed_selectors <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>	result.packed_selectors[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>(packed_selectors <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">8</span>);
</span></span><span style="display:flex;"><span>	result.packed_selectors[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>(packed_selectors <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">16</span>);
</span></span><span style="display:flex;"><span>	result.packed_selectors[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>(packed_selectors <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">24</span>);
</span></span><span style="display:flex;"><span>	result.packed_selectors[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>(packed_selectors <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">32</span>);
</span></span><span style="display:flex;"><span>	result.packed_selectors[<span style="color:#ae81ff">5</span>] <span style="color:#f92672">=</span> static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>(packed_selectors <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">40</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Our encode function will take a pointer to the 16 <code>uint8_t</code> values in the block, arranged in row-major order (the caller is required to reorder them from image order):</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
<td style="text-align:center">7</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">9</td>
<td style="text-align:center">10</td>
<td style="text-align:center">11</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">13</td>
<td style="text-align:center">14</td>
<td style="text-align:center">15</td>
</tr>
</tbody>
</table>
<p>In order to encode the block, we need to find a set of endpoints and selectors that minimize the error across the texels (typically measured as the sum of squared differences between original and decoded values).  Choosing different endpoints will (usually) change the ideal selectors chosen.  Choosing different selectors will (usually) change the ideal endpoints.</p>
<p>This search space is large, so a decent approach is to take a reasonable guess at good endpoints and find the optimal selectors for that pair.  A common choice is to assume the minimum and maximum values of the block will be close to the ideal endpoints:</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> v_min <span style="color:#f92672">=</span> in_pixels[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> v_max <span style="color:#f92672">=</span> in_pixels[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> k_texels_per_block; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> in_pixels[i];
</span></span><span style="display:flex;"><span>    v_min <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span><span style="color:#a6e22e">min</span>(v_min, v);
</span></span><span style="display:flex;"><span>    v_max <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span><span style="color:#a6e22e">max</span>(v_max, v);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Now we need to search for the correct selectors.  To do this, we compute our palette entries, then search for the best match for each texel (assuming, for now, that we always use the 8-color palette):</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>out_result<span style="color:#f92672">-&gt;</span>endpoint0 <span style="color:#f92672">=</span> static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>(v_max);
</span></span><span style="display:flex;"><span>out_result<span style="color:#f92672">-&gt;</span>endpoint1 <span style="color:#f92672">=</span> static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>(v_min);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">uint8_t</span> palette_entries[<span style="color:#ae81ff">8</span>] <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>(v_max),
</span></span><span style="display:flex;"><span>    static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>(v_min),
</span></span><span style="display:flex;"><span>    static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>((v_max <span style="color:#f92672">*</span> <span style="color:#ae81ff">6</span> <span style="color:#f92672">+</span> v_min <span style="color:#f92672">*</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">7</span>),
</span></span><span style="display:flex;"><span>    static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>((v_max <span style="color:#f92672">*</span> <span style="color:#ae81ff">5</span> <span style="color:#f92672">+</span> v_min <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">7</span>),
</span></span><span style="display:flex;"><span>    static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>((v_max <span style="color:#f92672">*</span> <span style="color:#ae81ff">4</span> <span style="color:#f92672">+</span> v_min <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">7</span>),
</span></span><span style="display:flex;"><span>    static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>((v_max <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">+</span> v_min <span style="color:#f92672">*</span> <span style="color:#ae81ff">4</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">7</span>),
</span></span><span style="display:flex;"><span>    static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>((v_max <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> v_min <span style="color:#f92672">*</span> <span style="color:#ae81ff">5</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">7</span>),
</span></span><span style="display:flex;"><span>    static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>((v_max <span style="color:#f92672">*</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> v_min <span style="color:#f92672">*</span> <span style="color:#ae81ff">6</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">7</span>),
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> k_texels_per_block; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> in_pixels[i];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Search for palette entry that minimizes the error:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint8_t</span> best_selector <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> best_error <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span><span style="color:#a6e22e">abs</span>(v <span style="color:#f92672">-</span> v_max);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint8_t</span> p <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; p <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">_countof</span>(palette_entries); <span style="color:#f92672">++</span>p)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> error <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span><span style="color:#a6e22e">abs</span>(v <span style="color:#f92672">-</span> palette_entries[p]);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (error <span style="color:#f92672">&lt;</span> best_error)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            best_selector <span style="color:#f92672">=</span> p;
</span></span><span style="display:flex;"><span>            best_error <span style="color:#f92672">=</span> error;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    out_result<span style="color:#f92672">-&gt;</span>selectors[i] <span style="color:#f92672">=</span> best_selector;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Tada!  A simple BC4 compressor.</p>
<p>To validate the results, I wrote a quick function to load an image, run the red channel through both our BC4 compressor and the one from <a href="https://github.com/richgel999/bc7enc/blob/master/rgbcx.h">rgbcx</a>, decode both blocks, and compare the outputs.  The results are not always exactly the same between the two; when a texel value falls directly between two palette entries, there may be two selectors with the same absolute error.  So, we often see cases where rgbcx encodes a texel with an error of +6, while the above code encodes it with an error of -6.</p>
<h3 id="improving-the-simple-compressor">
  <a class="Heading-link u-clickable" href="/posts/intro_bcn_part1/#improving-the-simple-compressor">Improving The Simple Compressor</a>
</h3>
<p>How do we go about making this trivial BC4 compressor better?  Are there simple things we can do to make it faster?  What about increasing the quality?</p>
<p>Of course there are.</p>
<p>Easy thing first:  after we&rsquo;ve determined the minimum and maximum values in the block, we can trivially detect the case where all values in the block are identical (minimum and maximum are equal.)  In that case, there&rsquo;s no point in computing palette entries and doing an expensive search; we can encode the block directly by placing the value in the first endpoint and setting all selectors to 0.  (The value of the other endpoint is irrelevant.)  This change doesn&rsquo;t affect the output, but saves us some time if there are constant blocks in the input:</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (v_min <span style="color:#f92672">==</span> v_max)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    out_result<span style="color:#f92672">-&gt;</span>endpoint0 <span style="color:#f92672">=</span> static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>(v_max);
</span></span><span style="display:flex;"><span>    out_result<span style="color:#f92672">-&gt;</span>endpoint1 <span style="color:#f92672">=</span> static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>(v_min);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memset</span>(out_result<span style="color:#f92672">-&gt;</span>selectors, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(out_result<span style="color:#f92672">-&gt;</span>selectors));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>(A small note here:  <a href="https://fgiesen.wordpress.com/2021/10/04/gpu-bcn-decoding/">BC4 and BC5 decode to more than 8 bit precision on the GPU</a>, so if you have higher-precision <em>input</em> textures you could solve for a more precise fit for these blocks, moving the endpoints so that an interpolated palette entry gives a more precise result.)</p>
<p>The rgbcx BC4 compressor is fast and has decent quality, but only considers the 8-color mode.  Can we improve things by using the alternative mode?  Let&rsquo;s try.</p>
<p>Let&rsquo;s pull the selector fit out into its own function, which tracks and returns the total squared error across all texels:</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">encode_bc4_fit_selectors_for_palette</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">*</span> palette_entries,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">*</span> in_pixels,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">*</span> out_selectors)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> total_sq_error <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> k_texels_per_block; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> in_pixels[i];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Search for palette entry that minimizes the error:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">uint8_t</span> best_selector <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> best_error <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span><span style="color:#a6e22e">abs</span>(v <span style="color:#f92672">-</span> (<span style="color:#66d9ef">int</span>)palette_entries[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint8_t</span> p <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; p <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">8</span>; <span style="color:#f92672">++</span>p)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">int</span> error <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span><span style="color:#a6e22e">abs</span>(v <span style="color:#f92672">-</span> (<span style="color:#66d9ef">int</span>)palette_entries[p]);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (error <span style="color:#f92672">&lt;</span> best_error)
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				best_selector <span style="color:#f92672">=</span> p;
</span></span><span style="display:flex;"><span>				best_error <span style="color:#f92672">=</span> error;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		out_selectors[i] <span style="color:#f92672">=</span> best_selector;
</span></span><span style="display:flex;"><span>		total_sq_error <span style="color:#f92672">+=</span> best_error <span style="color:#f92672">*</span> best_error;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> total_sq_error;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Then, we compute both palettes, encode the block twice, and take the one with the minimum total error:</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">uint8_t</span> interp8_palette[<span style="color:#ae81ff">8</span>] <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>(v_max),
</span></span><span style="display:flex;"><span>    static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>(v_min),
</span></span><span style="display:flex;"><span>    static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>((v_max <span style="color:#f92672">*</span> <span style="color:#ae81ff">6</span> <span style="color:#f92672">+</span> v_min <span style="color:#f92672">*</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">7</span>),
</span></span><span style="display:flex;"><span>    static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>((v_max <span style="color:#f92672">*</span> <span style="color:#ae81ff">5</span> <span style="color:#f92672">+</span> v_min <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">7</span>),
</span></span><span style="display:flex;"><span>    static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>((v_max <span style="color:#f92672">*</span> <span style="color:#ae81ff">4</span> <span style="color:#f92672">+</span> v_min <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">7</span>),
</span></span><span style="display:flex;"><span>    static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>((v_max <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">+</span> v_min <span style="color:#f92672">*</span> <span style="color:#ae81ff">4</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">7</span>),
</span></span><span style="display:flex;"><span>    static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>((v_max <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> v_min <span style="color:#f92672">*</span> <span style="color:#ae81ff">5</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">7</span>),
</span></span><span style="display:flex;"><span>    static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>((v_max <span style="color:#f92672">*</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> v_min <span style="color:#f92672">*</span> <span style="color:#ae81ff">6</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">7</span>),
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">uint8_t</span> interp6_palette[<span style="color:#ae81ff">8</span>] <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>(v_min),
</span></span><span style="display:flex;"><span>    static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>(v_max),
</span></span><span style="display:flex;"><span>    static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>((v_min <span style="color:#f92672">*</span> <span style="color:#ae81ff">4</span> <span style="color:#f92672">+</span> v_max <span style="color:#f92672">*</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">5</span>),
</span></span><span style="display:flex;"><span>    static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>((v_min <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">+</span> v_max <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">5</span>),
</span></span><span style="display:flex;"><span>    static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>((v_min <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> v_max <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">5</span>),
</span></span><span style="display:flex;"><span>    static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>((v_min <span style="color:#f92672">*</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> v_max <span style="color:#f92672">*</span> <span style="color:#ae81ff">4</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">5</span>),
</span></span><span style="display:flex;"><span>    static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">0</span>),
</span></span><span style="display:flex;"><span>    static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">255</span>),
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">uint8_t</span> interp8_selectors[k_texels_per_block];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> interp8_error <span style="color:#f92672">=</span> <span style="color:#a6e22e">encode_bc4_fit_selectors_for_palette</span>(
</span></span><span style="display:flex;"><span>    interp8_palette,
</span></span><span style="display:flex;"><span>    in_pixels,
</span></span><span style="display:flex;"><span>    interp8_selectors);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">uint8_t</span> interp6_selectors[k_texels_per_block];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> interp6_error <span style="color:#f92672">=</span> <span style="color:#a6e22e">encode_bc4_fit_selectors_for_palette</span>(
</span></span><span style="display:flex;"><span>    interp6_palette,
</span></span><span style="display:flex;"><span>    in_pixels,
</span></span><span style="display:flex;"><span>    interp6_selectors);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (interp8_error <span style="color:#f92672">&lt;</span> interp6_error)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    out_result<span style="color:#f92672">-&gt;</span>endpoint0 <span style="color:#f92672">=</span> static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>(v_max);
</span></span><span style="display:flex;"><span>    out_result<span style="color:#f92672">-&gt;</span>endpoint1 <span style="color:#f92672">=</span> static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>(v_min);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memcpy</span>(out_result<span style="color:#f92672">-&gt;</span>selectors, interp8_selectors, <span style="color:#66d9ef">sizeof</span>(interp8_selectors));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    out_result<span style="color:#f92672">-&gt;</span>endpoint0 <span style="color:#f92672">=</span> static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>(v_min);
</span></span><span style="display:flex;"><span>    out_result<span style="color:#f92672">-&gt;</span>endpoint1 <span style="color:#f92672">=</span> static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>(v_max);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memcpy</span>(out_result<span style="color:#f92672">-&gt;</span>selectors, interp6_selectors, <span style="color:#66d9ef">sizeof</span>(interp6_selectors));
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>This <em>does</em> improve the quality of the result slightly, but it is very slight.  (About a 0.5% improvement in RMSE.)  Turns out there&rsquo;s a reason rgbcx doesn&rsquo;t bother.  We&rsquo;re also doing two searches per block this way, which is&hellip; not great.</p>
<p>We still have a nice lever to improve performance significantly.  Currently, we search the list of palette values for the best match per-texel.  However, these palette values are not <em>random</em>, they&rsquo;re (for the most part) a linear gradient.  This is a quantization problem; as long as we&rsquo;re careful about rounding, we can compute the optimal selectors for a set of endpoints directly instead of searching for them.  Fabien Giesen has a short writeup on the math <a href="https://fgiesen.wordpress.com/2009/12/15/dxt5-alpha-block-index-determination/">here</a>.  Aside from the weirdness of the rounding bias and the need to remap from linear indices to selector order, this seems straightforward.</p>
<p>Implemented as an alternative to <code>encode_bc4_fit_selectors_for_palette</code>:</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">encode_bc4_fit_selectors_for_endpoints8</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> endpoint0,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> endpoint1,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">*</span> in_pixels,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">*</span> out_selectors)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Remap from lerp indices (min/max at ends) to selectors (min/max in first two entries.)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// I&#39;m sure there&#39;s a bit-twiddling way to do this, but a lookup table is simpler.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">uint8_t</span> k_index_to_selector_lut[<span style="color:#ae81ff">8</span>] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">0</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 8-color mode means endpoint0 is the maximum and endpoint1 is the minimum.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">assert</span>(endpoint0 <span style="color:#f92672">&gt;</span> endpoint1);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> range <span style="color:#f92672">=</span> endpoint0 <span style="color:#f92672">-</span> endpoint1;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> bias <span style="color:#f92672">=</span> (range <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">8</span>) <span style="color:#f92672">?</span> (range <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">:</span> (range <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint8_t</span> palette[<span style="color:#ae81ff">8</span>];
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">encode_bc4_compute_palette8</span>(palette, endpoint0, endpoint1);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> total_sq_error <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> k_texels_per_block; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> in_pixels[i];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> index <span style="color:#f92672">=</span> ((v <span style="color:#f92672">-</span> endpoint1) <span style="color:#f92672">*</span> <span style="color:#ae81ff">7</span> <span style="color:#f92672">+</span> bias) <span style="color:#f92672">/</span> range;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> selector <span style="color:#f92672">=</span> k_index_to_selector_lut[index];
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> error <span style="color:#f92672">=</span> v <span style="color:#f92672">-</span> palette[selector];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		out_selectors[i] <span style="color:#f92672">=</span> selector;
</span></span><span style="display:flex;"><span>		total_sq_error <span style="color:#f92672">+=</span> error <span style="color:#f92672">*</span> error;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> total_sq_error;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>(The 6-color mode version is similar, except it must also test the error for 0 and 255, picking those selectors when they&rsquo;re better.)</p>
<p>This runs noticably faster, and produces the same error.  We still need to compute the palette entries in order to compute local error; this is necessary to determine if 6-color mode produces a better output.  If we decide to only encode in 8-color mode, we never need to compute the palette entries at all.</p>
<h3 id="this-one-goes-to-eleven">
  <a class="Heading-link u-clickable" href="/posts/intro_bcn_part1/#this-one-goes-to-eleven">This One Goes To Eleven</a>
</h3>
<p>Computing selectors directly is significantly faster.  In fact, it improves performance enough that we can turn the quality level <em>all</em> the way up.</p>
<p>We have two endpoints at 8 bits apiece, and so our total endpoint size is 16 bits.  That gives us 65536 possible endpoint pairs.  If we want to determine the <em>optimal</em> BC4 encoding for each block, we can exhaustively test the full set of possible pairs, encode the optimal selectors for those endpoints, and take the result with lowest error:</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">encode_bc4_exhaustive</span>(<span style="color:#66d9ef">bc4_block_t</span><span style="color:#f92672">*</span> out_result, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">*</span> in_pixels)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> best_error <span style="color:#f92672">=</span> INT_MAX;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint8_t</span> temp_selectors[k_texels_per_block];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> endpoint0 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; endpoint0 <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">256</span>; <span style="color:#f92672">++</span>endpoint0)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> endpoint1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; endpoint1 <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">256</span>; <span style="color:#f92672">++</span>endpoint1)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (endpoint0 <span style="color:#f92672">&gt;</span> endpoint1)
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">int</span> error <span style="color:#f92672">=</span> <span style="color:#a6e22e">encode_bc4_fit_selectors_for_endpoints8</span>(
</span></span><span style="display:flex;"><span>                    endpoint0,
</span></span><span style="display:flex;"><span>                    endpoint1,
</span></span><span style="display:flex;"><span>                    in_pixels,
</span></span><span style="display:flex;"><span>                    temp_selectors);
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> (error <span style="color:#f92672">&lt;</span> best_error)
</span></span><span style="display:flex;"><span>				{
</span></span><span style="display:flex;"><span>					out_result<span style="color:#f92672">-&gt;</span>endpoint0 <span style="color:#f92672">=</span> static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>(endpoint0);
</span></span><span style="display:flex;"><span>					out_result<span style="color:#f92672">-&gt;</span>endpoint1 <span style="color:#f92672">=</span> static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>(endpoint1);
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">memcpy</span>(out_result<span style="color:#f92672">-&gt;</span>selectors, temp_selectors, <span style="color:#66d9ef">sizeof</span>(temp_selectors));
</span></span><span style="display:flex;"><span>					best_error <span style="color:#f92672">=</span> error;
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">int</span> error <span style="color:#f92672">=</span> <span style="color:#a6e22e">encode_bc4_fit_selectors_for_endpoints6</span>(
</span></span><span style="display:flex;"><span>                    endpoint0,
</span></span><span style="display:flex;"><span>                    endpoint1,
</span></span><span style="display:flex;"><span>                    in_pixels,
</span></span><span style="display:flex;"><span>                    temp_selectors);
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> (error <span style="color:#f92672">&lt;</span> best_error)
</span></span><span style="display:flex;"><span>				{
</span></span><span style="display:flex;"><span>					out_result<span style="color:#f92672">-&gt;</span>endpoint0 <span style="color:#f92672">=</span> static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>(endpoint0);
</span></span><span style="display:flex;"><span>					out_result<span style="color:#f92672">-&gt;</span>endpoint1 <span style="color:#f92672">=</span> static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span>(endpoint1);
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">memcpy</span>(out_result<span style="color:#f92672">-&gt;</span>selectors, temp_selectors, <span style="color:#66d9ef">sizeof</span>(temp_selectors));
</span></span><span style="display:flex;"><span>					best_error <span style="color:#f92672">=</span> error;
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>As you might expect, this is quite slow!  I certainly wouldn&rsquo;t put this in a production pipeline.  However, it&rsquo;s always nice to have a simple, brute force path to The Correct Result.  It gives a nice baseline from which to evaluate other options.  You could also use this as a fallback in a high-quality compressor, exhaustively encoding blocks that produce high amounts of error.</p>
<h3 id="conclusion">
  <a class="Heading-link u-clickable" href="/posts/intro_bcn_part1/#conclusion">Conclusion</a>
</h3>
<p>Hopefully this has been a useful introduction to the simplest case of BCn block compression.  We&rsquo;re not <em>quite</em> ready to takle the other formats:  there are a number of techniques for improving quality that we should cover first.  However, I&rsquo;ll leave this first post here for now as an overview of the basic technique.</p>
<p>There is much more to cover even with BC4, so expect a followup post soon discussing how to squeeze out more quality <em>without</em> resorting to brute force.</p>
<p>Until then, thanks for reading!</p>

    


  

  





  <footer>
    
      
    
      
        <ul class="Tags">
          
            <li class="Tags-item u-background">
              <a class="Tags-link u-clickable" href="/tags/code/" rel="tag">code</a>
            </li>
          
            <li class="Tags-item u-background">
              <a class="Tags-link u-clickable" href="/tags/compression/" rel="tag">compression</a>
            </li>
          
        </ul>
      
    
  </footer>

    
  

  </article>


      </div>
    </div>
  </main>
  
  <footer class="Footer">
    <div class="u-wrapper">
      <div class="u-padding u-noboosting">
        <a href=https://mastodon.gamedev.place/@ataylor>🐘</a>
      </div>
    </div>
  </footer>

</body>

</html>
